# 1.8 Функции

## Функции

Функции в javascript это специальный тип объектов, с помощью которых можно задавать определенную логику для обработки данных.

Любая **функция это объект,** и следовательно ею можно манипулировать как объектом, в частности:

* передавать как аргумент и возвращать в качестве результата при вызове других функций
* создавать анонимно и присваивать в качестве значений переменных или свойств объектов.

### Объявление функций

#### function decloration

Объявление функции \(_function definition_, или _function declaration_, или _function statement_\) состоит из ключевого слова `function`, имя функции, параметров указываемых в `( )` и тела функции которое будет выполнено  после вызова.

Создадим функцию `add`

```javascript
function add(number) {
  return add + 1;
}
```

Функция add принимает один параметр number, добавляет к нему 1 и возвращает полученный результат.

Примитивные параметры переданные функции значением, не изменяются, но если передать объект и функция изменит его значения, то эти изменения отобразятся глобально.

```javascript
var x = 5;
var obj = {name: 'John'}
function sum(n) {
  n + 1
}
function changeObj(obj) {
  obj.name = 'Carl'
}
console.log(x) // 5
console.log(obj.name) // John
sum(x)
changeObj(obj)
console.log(x) // 5
console.log(obj.name) // Carl
```

#### function expression

Существует другой способ объявления функция который называется "функциональное выражение".

```javascript
var x = 5;
var sum = function(n) {
  n + 1
}

sum(5) // 6
```

Такая функция может быть анонимной, но можно и присвоить имя для рекурсии 

```javascript
var factorial = function fac(n) { return n < 2 ? 1 : n * fac(n - 1); };

console.log(factorial(3));
```

Function expression удобны для передачи аргументом.  Следующий пример показывает функцию `map`, которая должна получить функцию первым аргументом и массив вторым.

```javascript
function map(f, a) {
  var result = [], // Создание нового массива
  var i; // Создание переменной 
  for (i = 0; i != a.length; i++) 
    result[i] = f(a[i]); // применяет фунецию f для каждого элемента массива
  return result;
}

var f = function(x) { . // function expression
   return x * x * x; 
}
var numbers = [0, 1, 2, 5, 10];
var cube = map(f, numbers); // передаем аргументы 
```

В JavaScript функция может быть объявлена с условием. Например, следующая функция будет присвоена переменной `myFunc` только, если `data` равно `true`: 

```javascript
var myFunc;
var data = true;

if (data) {
  myFunc = function() {
    console.log("done")
  }
}
```

#### Конструктор Function

Для создания функции в рантайме можно использовать конструктор `Function`.

Конструктор `Function` создаёт новый объект `Function`. В JavaScript каждая функция является объектом `Function`.

```text
new Function([arg1[, arg2[, ...argN]],] functionBody)
```

Аргументы и тело функции должны быть строками.

```javascript
var adder = new Function('a', 'b', 'return a + b');

adder(2, 6) // 8
```

### Вызовы функций

Что бы выполнить действия написаные в теле функции ее нужно вызвать. К примеру так. 

```javascript
myFunc(1)
```

Этот вызов выполнит функцию с аргументом 1

Функции могут быть в области видимости, когда они уже определены, но функции вида "function declaration statment" могут быть подняты\(hoisting\), также как в этом примере:

```javascript
console.log(square(5)); //25

function square(n) { return n * n; }
```

c function expression будет следующий результат

```javascript
console.log(square); // square поднят со значением undefined.
console.log(square(5)); // TypeError: square is not a function
var square = function(n) { 
  return n * n; 
}
```

### Область видимости функций

Переменные объявленные в функции не могут быть доступными где-нибудь вне этой функции, поэтому переменные \(которые нужны именно для функции\) объявляют только в scope функции. При этом функция имеет доступ ко всем переменным и функциям, объявленным внутри её scope. Другими словами функция объявленная в глобальном scope имеет доступ ко всем переменным в глобальном scope. Функция объявленная внутри другой функции ещё имеет доступ и ко всем переменным её родителькой функции и другим переменным, к которым эта родительская функция имеет доступ.

```javascript
// Следующие переменные объявленны в глобальном scope
var num1 = 20,
    num2 = 3,
    name = 'Chamahk';

// Эта функция объявленна в глобальном scope
function multiply() {
  return num1 * num2;
}

multiply(); // вернет 60

// Пример вложенной функции
function getScore() {
  var num1 = 2,
      num2 = 3;
  
  function add() {
    return name + ' scored ' + (num1 + num2);
  }
  
  return add();
}

getScore(); // вернет "Chamahk scored 5"
```

## Scope и стек функций

#### Рекурсия, контекст, стек

Рекурсия - это когда функция вызывает сама себя.

```javascript
const func = (a, b) => func(2,3)
```

Контекст - В js у каждого вызова функции есть контекст выполнения \(execution context\), в контексте хранятся промежуточные результаты выполнения функции, до тех пор пока функция не будет выполнена.

```javascript
func(2, 3) // вызов функции

{context: {a: 2, b: 3, line: 1}} // примерно так это выглядит в контексте выполнения функции
```

И так по каждой строке кода, если есть что хранить то записывается в контекст выполнения. Что еще нужно знать о контексте выполнения \(execution context\)

* 1. перед выполнения кода, сначала создается контекст выполнения \(определяется this, создается лексическое окружение, определяются переменные\)
* 1. есть глобальный контекст - всего кода, и контекст выполнения функции

Подробнее можно почитать тут:

* [understanding-execution-context-and-execution-stack](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)
* [Контекст выполнения и стек вызовов в JavaScript \(перевод\)](https://medium.com/webbdev/js-a4a9dfed9782)

Стек выполнения \(execution stack\), он же стек вызовов \(call stack\), LIFO-стек или же просто стек, используется для хранения контекстов выполнения, создаваемых в ходе работы кода;

```javascript
{context: {a: 2, b: 3, line: 1}}
{context: {a: 2, b: 3, line: 1}}
{context: {a: 2, b: 3, line: 1}} // примерно так это выглядит в контексте выполнения функции
```

И так мы хотим сделать рекурсивную функцию. Сделаем пример с функцией pow \(возведения x в степень n\); 1. Создаем функцию

```javascript
function pow(x, n) { //
  if (n != 1) {
    return x * pow(x, n - 1);
  } else {
    return x;
  }
}
```

1. Запускается с аргументами 2, 3

   ```javascript
   pow(2, 3)
   ```

2. Аргументы записались в контекст выполнения 

   ```javascript
   function pow(x, n) { // {context: {a: 2, b: 3, line: 1}}
    if (n != 1) {
     return x * pow(x, n - 1);  // новый вызов, новый контекст {a: 2, b: 3, line: 3}
    } else {
     return x;
    }
   }
   ```

   На 3 строке встречает рекурсию, проводит вычисления и записывает все в контекст выполнения

   ```javascript
   {context: {a: 2, b: 3, line: 3}} //старый контекст
   {context: {a: 2, b: 2, line: 3}} //старый контекст
   {context: {a: 2, b: 1, line: 1}} //текущий
   // Это назыавется стэком контекста
   ```

   Дальше функция упирается в else, здесь вложенных вызовов нет, так что функция заканчивает свою работу, возвращая 2. 

   Текущий контекст больше не нужен и удаляется из памяти, из стека восстанавливается предыдущий:

   {context: {a: 2, b: 3, line: 3}} //старый контекст

   {context: {a: 2, b: 2, line: 3}} // текущий

продолжает подъем, контекст {x:2, n2} возвращает 4, текущий стек снова больше не нужен и удаляется, восстанавливается {context: {a: 2, b: 3, line: 3}} Самый внешний вызов заканчивает свою работу, его результат: pow\(2, 3\) = 8.

#### Вложенные функции \(nested functions\) и замыкания \(closures\) <a id="&#x412;&#x43B;&#x43E;&#x436;&#x435;&#x43D;&#x43D;&#x44B;&#x435;_&#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x438;_(nested_functions)_&#x438;_&#x437;&#x430;&#x43C;&#x44B;&#x43A;&#x430;&#x43D;&#x438;&#x44F;_(closures)"></a>

Вы можете вложить одну функцию в другую. Вложенная функция \(_nested function_; _inner_\) приватная \(_private_\) и она помещена в другую функцию \(_outer_\). Так образуется _замыкание_\(_closure_\). Closure — это выражение \(обычно функция\), которое может иметь свободные переменные вместе со средой, которая связывает эти переменые \(что "закрывает" \(_"close"_\) выражение\).

Поскольку вложенная функция это closure, это означает, что вложенная функция может "унаследовать" \(_inherit_\) аргументы и переменные функции, в которую та вложена. Другими словами, вложенная функция содержит scope внешней \(_"outer"_\) функции.

Подведем итог:

* Вложенная функция имеет доступ ко всем инструкциям внешней функции.
* Вложенная функция формирует closure: она может использовать аргументы и переменные внешней функции, в то время как внешняя функция не может использовать аргументы и переменные вложенной функции.

Следующий пример показывает вложенную функцию:

```javascript
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
a = addSquares(2, 3); // возвращает 13
b = addSquares(3, 4); // возвращает 25
c = addSquares(4, 5); // возвращает 41
```

```javascript
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
a = addSquares(2, 3); // возвращает 13
b = addSquares(3, 4); // возвращает 25
c = addSquares(4, 5); // возвращает 41
```

Поскольку вложенная функция формирует closure, Вы можете вызвать внешную функцию и указать аргументы для обоих функций \(для outer и innner\).

```javascript
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}
fn_inside = outside(3); // Подумайте над этим: дайте мне функцию,
                        // который передай 3

result = fn_inside(5); // возвращает 8

result1 = outside(3)(5); // возвращает 8
```

#### Сохранение переменных <a id="&#x421;&#x43E;&#x445;&#x440;&#x430;&#x43D;&#x435;&#x43D;&#x438;&#x435;_&#x43F;&#x435;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x44B;&#x445;"></a>

Обратите внимание, значение `x` сохранилось, когда возвращалось `inside`. Closure должно сохранять аргументы и переменные во всем scope. Поскольку каждый вызов предоставляет потенциально разные аргументы, создается новый closure для каждого вызова во вне. Память может быть очищена только тогда, когда `inside` уже возвратился и больше не доступен.

Это не отличается от хранения ссылок в других объектах, но часто менее очевидно, потому что не устанавливаются ссылки напрямую и нельзя посмотреть там.

#### Несколько уровней вложенности \(Multiply-nested functions\) <a id="&#x41D;&#x435;&#x441;&#x43A;&#x43E;&#x43B;&#x44C;&#x43A;&#x43E;_&#x443;&#x440;&#x43E;&#x432;&#x43D;&#x435;&#x439;_&#x432;&#x43B;&#x43E;&#x436;&#x435;&#x43D;&#x43D;&#x43E;&#x441;&#x442;&#x438;_&#x444;&#x443;&#x43D;&#x43A;&#x446;&#x438;&#x439;_(Multiply-nested_functions)"></a>

Функции можно вкладывать друг в друга т.е. функция `fn1` хранит в себе функцию `fn2`, которая в свою очередь хранит в себе функцию `fn3`. Функции `fn2` и `fn3` создают замыкание, так `fn2` имеет доступ к переменным и аргументам `fn1`, а функция `fn3` имеет  доступ к `fn2`. Но поскольку `fn2` имеет доступ к `fn1`, `fn3` имеет доступ и к `fn1` через `fn2`. Таким образом замыкание может хранить в себе несколько scope, они рекурсивно хранят scope функций, содержащих его. Это называется _chaining._

```javascript
function fn1(a) {
  function fn2(b) {
    function fn3(c) {
      console.log(a + b + c);
    }
    C(3);
  }
  B(2);
}
A(1); // 6
```

В этом примере fn3 имеет доступ к аргументам `a` и `b` . Так получается, потому что:

1. Функция `fn2` формирует замыкание\(closure\), получающие доступ к `fn1`
2. Функция `fn3` формирует closure, включающее `fn2`.
3. fn3 создает _цепь_ \(_chain_\)  из скоупов \(scopes\) функций `fn2` и `fn1` в таком порядке.

В обратном порядке это работать не будет, т.к. `fn1` не имеет доступ к переменным и аргументам `fn3` и `fn2` Таким образом, `fn3` остается приватным только для `fn2`.

#### Конфликты имен \(Name conflicts\) <a id="&#x41A;&#x43E;&#x43D;&#x444;&#x43B;&#x438;&#x43A;&#x442;&#x44B;_&#x438;&#x43C;&#x435;&#x43D;_(Name_conflicts)"></a>

Когда два аргумента или переменных в scope у замыкания \(closure\) имеют одинаковые имена, происходит _конфликт имен_ \(_name conflict_\). Более вложенный \(_more inner_\) scope имеет приоритет, так самый вложенный scope имеет наивысший приоритет, и наоборот. Это цепочка областей видимости \(_scope chain_\). Самым первым звеном является самый глубокий scope, и наоборот. Рассмотрим следующие:

```javascript
function outside() {
  var x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

outside()(10); // возвращает 20, а не 10
```

Конфликт имени произошел в инструкции `return x * 2` между параметром `x` функции `inside` и переменной `x` функции `outside`. Scope chain здесь будет таким: {`inside`==&gt; `outside` ==&gt; глобальный объект \(_global object_\)}. Следовательно `x` функции `inside`имеет больший приоритет по сравнению с `outside`, и нам вернулось 20 \(= 10 \* 2\), а не 10 \(= 5 \* 2\).

## Замыкания \(closures\)

Замыкания это один из главных особенностей JavaScript. JavaScript разрешает вложенность функций и предоставляет вложенной функции полный доступ ко всем переменным и функциям, объявленным внутри родительской функции \(и другим переменным и функциям, к которым имеет доступ родительская функция\).

Однако, внешняя функция не имеет доступа к переменным и функциям, объявленным во внутренней функции. Это обеспечивает своего рода инкапсуляцию для переменных внутри вложенной функции.

Также, поскольку вложенная функция имеет доступ к scope внешней функции, переменные и функции, переменные объявленные во внешней функции, сохраняются, только если внутренняя функция обращается к ним

Замыкание создается, когда вложенная функция как-то стала доступной в неком scope вне внешней функции.

```javascript
var pet = function(name) {   // Внешняя функция объявила переменную "name"
  var getName = function() {
    return name;             // Вложенная функция имеет доступ к "name" внешней функции
  }
  return getName;            // Возвращаем вложенную функцию, тем самым сохраняя доступ
                             // к ней для другого scope
}
myPet = pet('Vivie');
   
myPet();                     // Возвращается "Vivie",
                             // т.к. даже после выполнения внешней функции
                             // name сохранился для вложенной функции
```

Более сложный пример представлен ниже. Объект с методами для манипуляции вложенной функции внешней функцией можно вернуть \(_return_\).

```javascript
var createPet = function(name) {
  var sex;
  
  return {
    setName: function(newName) {
      name = newName;
    },
    
    getName: function() {
      return name;
    },
    
    getSex: function() {
      return sex;
    },
    
    setSex: function(newSex) {
      if(typeof newSex === 'string' && (newSex.toLowerCase() === 'male' || 
        newSex.toLowerCase() === 'female')) {
        sex = newSex;
      }
    }
  }
}

var pet = createPet('Vivie');
pet.getName();                  // Vivie

pet.setName('Oliver');
pet.setSex('male');
pet.getSex();                   // male
pet.getName();                  // Oliver
```

В коде выше переменная `name` родительской функции доступна для вложенной функции, и нет другого способа доступа к вложенным переменным кроме как через вложенную функцию. Вложенные переменные вложенной функции являются безопасными хранилищами для внешних аргументов и переменных. Они содержат "постоянные" и "инкапсулированные" данные для работы с ними вложенными функциями. Функции даже не должны присваиваться переменной или иметь имя.

### Объект arguments

Объект arguments функции является псевдо-массивом. Внутри функции вы можете обратиться к аргументам следующим образом

```javascript
arguments[i]
```

где `i` — индекс массива. Что бы узнать кол-во аргументов используйте`arguments.length`.

С помощью объекта `arguments` вы можете вызвать функцию, передавая в неё больше аргументов, чем формально объявили принять. Это нужно есчли вы не знаете сколько аргументов должна принять ваша функция. 

Для примера рассмотрим функцию, которая конкатенирует несколько строк. Единственным формальным аргументом для функции будет строка, которая указывает символы, которые разделяют элементы для конкатенации. Функция определяется следующим образом:

```javascript
function myConcat(separator) {
   var result = '';
   var i;

   // iterate through arguments
   for (i = 1; i < arguments.length; i++) {
      result += arguments[i] + separator;
   }
   return result;
}
```

Вы можете передавать любое количество аргументов в эту функцию, и он  конкатенирует каждый аргумент в одну строку.

```javascript
// возвращает "red, orange, blue, "
myConcat(', ', 'red', 'orange', 'blue');

// возвращает "elephant; giraffe; lion; cheetah; "
myConcat('; ', 'elephant', 'giraffe', 'lion', 'cheetah');

// возвращает "sage. basil. oregano. pepper. parsley. "
myConcat('. ', 'sage', 'basil', 'oregano', 'pepper', 'parsley');
```

{% hint style="warning" %}
**Примечание:** `arguments` является псевдо-массивом, но не массивом. Это псевдо-массив, в котором есть пронумерованные индексы и свойство `length`. Однако он не обладает всеми методами массивов.
{% endhint %}

### Параметры функций 

Начиная с ECMAScript 2015 появились два новых вида параметров: параметры по умолчанию \(_default parameters_\) и оставшиеся параметры \(_rest parameters_\).

#### Default parameters 

до es6, параметрами по умолчанию был undefined, теперь их можно задать, делается это через оператор равно, на этапе формирования параметров функции 

```javascript
function multiply(a, b = 1) {
  return a * b;
}

multiply(5);
```

#### Rest params

Rest parameters предоставляют нам массив неопределенных аргументов. В примере мы используем оставшиеся параметры, чтобы собрать аргументы с индексами со 2-го до последнего. Затем мы умножим каждый из них на значение первого аргумента.

```javascript
function multiply(multiplier, ...theArgs) {
  return theArgs.map(x => multiplier * x);
}

var arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

## Стрелочные функции

[Стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions) — функции вида "arrow function expression" — имеют укороченный ситаксис по сравнению с function expression и лексически связывает значение `this`. Стрелочные функции всегда анонимны. Посмотрите также пост блога hacks.mozilla.org "[ES6 In Depth: Arrow functions](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/)".

На введение стрелочных функций повлияли два фактора: более короткие функции и лексика `this`.

#### контекст this

До стрелочных функций каждая новая функция определяла свое значение `this` \(новый объект в случае конструктора, undefined в strict mode,  контекстный объект, если функция вызвана как метод объекта, и т.д.\).  Это оказалось раздражающим с точки зрения объектно-орентированного стиля программирования.

```javascript
function Person() {
  // Конструктор Person() определяет `this` как самого себя.
  this.age = 0;

  setInterval(function growUp() {
    // Без strict mode функция growUp() определяет `this` 
    // как global object, который отличается от `this`
    // определенного конструктором Person().
    this.age++;
  }, 1000);
}

var p = new Person();
```

В ECMAScript 3/5 эта проблема была исправлена путем присвоения значения `this` переменной, которую можно было бы замкнуть.

```javascript
function Person() {
  var self = this; // Некоторые выбирают `that` вместо `self`. 
                   // Выберите что-то одно и будьте последовательны.
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

Альтернативой может быть [связанная функция](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) \(_bound function_\), с которой можно правильно вручную определить значение `this` для функции `growUp()`.

В arrow function значением `this` является окружающий его контекст, так следующий код работает ожидаемо:

```javascript
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // |this| должным образом ссылается на объект Person
  }, 1000);
}

var p = new Person();
```

